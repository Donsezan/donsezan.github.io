<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Tic‑Tac‑Toe (Blue & White)</title>
  <style>
    :root{--bg:#ffffff;--blue:#0b66ff;--light-blue:#cfe3ff;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--light-blue),#fff)}
    .page{min-height:100%;display:flex;flex-direction:column;align-items:center;padding:18px;box-sizing:border-box}
    h1{color:var(--blue);margin:8px 0 6px;font-size:20px}
    .controls{display:flex;gap:8px;margin:12px 0}
    button{background:var(--blue);color:white;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    button.secondary{background:white;color:var(--blue);border:2px solid var(--blue)}
    #game-container{width:820px;height:520px;border-radius:12px;background:linear-gradient(180deg,#f7fbff,#ffffff);box-shadow:0 8px 28px rgba(11,102,255,0.06);overflow:hidden}
    .footer{margin-top:14px;color:#345;font-size:13px}
    .help-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:white;padding:18px;border-radius:12px;box-shadow:0 20px 50px rgba(11,102,255,0.18);max-width:720px;width:92%;display:none;z-index:50}
    .help-modal.open{display:block}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.28);display:none}
    .overlay.open{display:block}
    .banner{background:#fff8ef;border:1px solid #ffd8a8;padding:8px;border-radius:8px;color:#664200;margin-bottom:12px;max-width:820px}
    @media (max-width:880px){#game-container{width:94vw;height:60vh}}
  </style>
</head>
<body>
  <div class="page">
    <h1>3D Tic‑Tac‑Toe</h1>

    <div id="warning" class="banner" style="display:none">Note: Your browser or environment blocked ES module imports. The page uses UMD builds of three.js and OrbitControls to ensure compatibility.</div>

    <div id="game-container" aria-label="3D board"></div>

    <div class="controls">
      <button id="restartBtn">Restart</button>
      <button id="helpBtn" class="secondary">Help</button>
    </div>

    <div class="footer">Rotate the board with mouse/touch drag — use scroll or pinch to zoom.</div>

    <div class="overlay" id="overlay"></div>
    <div class="help-modal" id="help">
      <h3 style="margin:0 0 8px;color:var(--blue)">How to interact</h3>
      <p style="margin:0 0 8px">Use mouse or touch to rotate the 3D board. Zoom with wheel/pinch. This demo renders a true 3×3×3 cubic wireframe. Clickable gameplay can be added on request.</p>
      <div style="display:flex;justify-content:flex-end;margin-top:12px"><button id="closeHelp">Close</button></div>
    </div>
  </div>

  <!-- Use UMD (non-module) builds to avoid module resolution issues in sandboxed environments -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

  <script>
    // Defensive checks: ensure THREE exists
    if (typeof THREE === 'undefined') {
      const w = document.getElementById('warning');
      w.textContent = 'Error: three.js failed to load. Check your network or CDN access.';
      w.style.display = 'block';
      console.error('three.js is not loaded. Aborting 3D initialization.');
      throw new Error('three.js is not loaded');
    }

    const container = document.getElementById('game-container');

    // renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    container.appendChild(renderer.domElement);

    // scene & camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf7fbff);
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(6, 8, 10);

    // controls (UMD build adds THREE.OrbitControls or window.OrbitControls)
    let controls = null;
    try {
      if (typeof THREE.OrbitControls === 'function') controls = new THREE.OrbitControls(camera, renderer.domElement);
      else if (typeof window.OrbitControls === 'function') controls = new window.OrbitControls(camera, renderer.domElement);
    } catch (err) {
      console.warn('OrbitControls init failed:', err);
      controls = null;
    }
    if (controls) {
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 4;
      controls.maxDistance = 30;
      controls.target.set(0, 1.5, 0);
      controls.update();
    } else {
      document.getElementById('warning').style.display = 'block';
      document.getElementById('warning').textContent = 'OrbitControls not found — the view will auto-rotate.';
    }

    // resize helper
    function onResize(){
      const w = container.clientWidth || 640;
      const h = container.clientHeight || 480;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();

    // lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // materials (blue and white theme)
    const lineColor = 0x0b66ff;
    const lineMat = new THREE.LineBasicMaterial({ color: lineColor });
    const cellSize = 1;

    // Build a full 3×3×3 wireframe cube grid
    const cubeGroup = new THREE.Group();
    // We'll create lines for grid coordinates 0..3 (4 lines per axis) to form 3x3x3 cells

    // Lines parallel to Z (vary x,y)
    for (let x = 0; x <= 3; x++) {
      for (let y = 0; y <= 3; y++) {
        const zGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(x * cellSize - 1.5 * cellSize, y * cellSize - 1.5 * cellSize, -1.5 * cellSize),
          new THREE.Vector3(x * cellSize - 1.5 * cellSize, y * cellSize - 1.5 * cellSize,  1.5 * cellSize)
        ]);
        cubeGroup.add(new THREE.Line(zGeom, lineMat));
      }
    }

    // Lines parallel to X (vary y,z)
    for (let y = 0; y <= 3; y++) {
      for (let z = 0; z <= 3; z++) {
        const xGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(-1.5 * cellSize, y * cellSize - 1.5 * cellSize, z * cellSize - 1.5 * cellSize),
          new THREE.Vector3( 1.5 * cellSize, y * cellSize - 1.5 * cellSize, z * cellSize - 1.5 * cellSize)
        ]);
        cubeGroup.add(new THREE.Line(xGeom, lineMat));
      }
    }

    // Lines parallel to Y (vary x,z)
    for (let x = 0; x <= 3; x++) {
      for (let z = 0; z <= 3; z++) {
        const yGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(x * cellSize - 1.5 * cellSize, -1.5 * cellSize, z * cellSize - 1.5 * cellSize),
          new THREE.Vector3(x * cellSize - 1.5 * cellSize,  1.5 * cellSize, z * cellSize - 1.5 * cellSize)
        ]);
        cubeGroup.add(new THREE.Line(yGeom, lineMat));
      }
    }

    // optional layer labels (sprites) centered on each layer for clarity
    for (let z = 0; z < 3; z++) {
      const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(11,102,255,0.02)'; ctx.fillRect(0,0,256,64);
      ctx.fillStyle = '#0b66ff'; ctx.font = '28px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('Layer ' + (z+1), 128, 32);
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false }));
      sprite.position.set(0, 0, (z-1) * cellSize);
      sprite.scale.set(2.2, 0.6, 1);
      cubeGroup.add(sprite);
    }

    // center cube at world origin
    cubeGroup.position.set(0, 0, 0);
    const boardGroup = new THREE.Group();
    boardGroup.add(cubeGroup);
    scene.add(boardGroup);

    // demo rotation when controls are not available
    let demoRotate = 0.002;

    // render loop
    function animate() {
      requestAnimationFrame(animate);
      if (controls) controls.update();
      else boardGroup.rotation.y += demoRotate;
      renderer.render(scene, camera);
    }
    animate();

    // UI hooks
    document.getElementById('helpBtn').addEventListener('click', () => {
      document.getElementById('help').classList.add('open');
      document.getElementById('overlay').classList.add('open');
    });
    document.getElementById('closeHelp').addEventListener('click', () => {
      document.getElementById('help').classList.remove('open');
      document.getElementById('overlay').classList.remove('open');
    });
    document.getElementById('overlay').addEventListener('click', () => {
      document.getElementById('help').classList.remove('open');
      document.getElementById('overlay').classList.remove('open');
    });
    document.getElementById('restartBtn').addEventListener('click', () => {
      // reset camera and controls to default view
      camera.position.set(6,8,10);
      if (controls) { controls.target.set(0,1.5,0); controls.update(); }
      boardGroup.rotation.set(0,0,0);
    });

  </script>
</body>
</html>
